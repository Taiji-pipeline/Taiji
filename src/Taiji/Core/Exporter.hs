-- Export results generated by Taiji for visualization by external programs.
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
module Taiji.Core.Exporter (exportResults) where

import           Bio.Data.Experiment
import           Bio.Pipeline.Utils     (asDir, getPath)
import           Bio.Utils.Misc         (readDouble)
import           Codec.Compression.GZip (bestCompression, compressLevel,
                                         compressWith, defaultCompressParams)
import           Control.DeepSeq        (($!!))
import           Control.Lens           ((^.))
import           Control.Monad
import           Control.Monad.IO.Class (liftIO)
import           Control.Monad.Reader   (asks)
import           Data.Binary            (decodeFile, encode)
import qualified Data.ByteString.Char8  as B
import qualified Data.ByteString.Lazy   as BL
import           Data.CaseInsensitive   as CI (CI, mk, original)
import           Data.Char              (toLower, toUpper)
import           Data.List.Ordered      (nubSort)
import qualified Data.Map.Strict        as M
import qualified Data.Matrix.Unboxed    as MU
import           Data.Maybe
import qualified Data.Text              as T
import           Data.Text.Encoding     (decodeUtf8, encodeUtf8)
import qualified Data.Vector            as V
import           IGraph                 (getNodes, nodeLab, pre, suc, mapNodes)
import           Scientific.Workflow

import           Taiji.Core.Functions   (linkageToGraphWithDefLabel)
import           Taiji.Types

exportResults :: ( FilePath    -- ^ File storing the PageRank results
                 , Maybe (File '[] 'Tsv) -- ^ Gene expression
                 , [(T.Text, File '[] 'Other)] )
              -> WorkflowConfig TaijiConfig FilePath
exportResults (pagerank, expr, es) = do
    dir <- asks _taiji_output_dir >>= getPath . asDir
    let output = dir ++ "/TaijiResults.bin.gz"
    liftIO $ do
        table <- readData pagerank $ fmap (^.location) expr
        nets <- forM es $ \(ct, e) -> do
            links <- decodeFile $ e^.location
            let gr = mapNodes (\_ x -> fst x) $ linkageToGraphWithDefLabel () () links
                results = M.fromList $ flip mapMaybe (V.toList $ rowNames table) $
                    \x -> case getNodes gr (mk $ encodeUtf8 x) of
                        [] -> Nothing
                        (i:_) ->
                            let children = B.intercalate "\t" $
                                    map (format . original . nodeLab gr) $ pre gr i
                                parents = B.intercalate "\t" $
                                    map (format . original . nodeLab gr) $ suc gr i
                            in Just (x, decodeUtf8 $ parents `B.append` "+" `B.append` children)
            return $!! (ct, results)
        BL.writeFile output $
            compressWith defaultCompressParams{compressLevel=bestCompression} $
            encode $ TaijiResults table $ M.fromList nets
        return output
  where
    format x = let (a, b) = B.splitAt 1 x
               in B.map toUpper a `B.append` B.map toLower b

-- | Read data, normalize and calculate p-values.
readData :: FilePath   -- ^ PageRank
         -> Maybe FilePath   -- ^ Gene expression
         -> IO RankTable
readData input1 input2 = do
    rank <- readTSV <$> B.readFile input1
    let (k1, k2) = unzip $ M.keys rank
        rowlab = V.fromList $ nubSort k1
        collab = V.fromList $ nubSort k2
        rank' = MU.generate (length rowlab, length collab) $ \(i, j) ->
            M.findWithDefault undefined (rowlab V.! i, collab V.! j) rank
    expr <- case input2 of
        Nothing -> return Nothing
        Just input -> do
            expr <- (fmap log' . readTSV) <$> B.readFile input
            return $ Just $ MU.generate (length rowlab, length collab) $
                \(i, j) -> M.findWithDefault 0 (rowlab V.! i, collab V.! j) expr

    return $ RankTable (V.map format rowlab) (V.map format collab)
        rank' expr
  where
    log' x | x == 0 = log 0.01
           | otherwise = log x
    format x = let (a, b) = B.splitAt 1 $ original x
               in decodeUtf8 $ B.map toUpper a `B.append` B.map toLower b

readTSV :: B.ByteString -> M.Map (CI B.ByteString, CI B.ByteString) Double
readTSV input = M.fromList $ concatMap (f . B.split '\t') content
  where
    f (x:xs) = zipWith (\s v -> ((mk x, mk s), readDouble v)) samples xs
    (header:content) = B.lines input
    samples = tail $ B.split '\t' header
